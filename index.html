<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>sheep-viz</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500;600;700&display=swap');

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'JetBrains Mono', monospace;
      background: #0a0a0f;
      color: #e8e8ed;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 40px 20px;
    }

    h1 {
      font-size: 48px;
      font-weight: 700;
      margin-bottom: 8px;
      background: linear-gradient(135deg, #6366f1, #ec4899, #06b6d4);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }

    .tagline {
      font-size: 14px;
      color: #8888a0;
      margin-bottom: 48px;
    }

    .visualizers {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 20px;
      max-width: 1400px;
      width: 100%;
      margin-bottom: 48px;
    }

    @media (max-width: 1200px) {
      .visualizers {
        grid-template-columns: repeat(3, 1fr);
      }
    }

    @media (max-width: 900px) {
      .visualizers {
        grid-template-columns: repeat(2, 1fr);
      }
    }

    @media (max-width: 600px) {
      .visualizers {
        grid-template-columns: 1fr;
      }
    }

    .card {
      background: #12121a;
      border: 1px solid #1a1a24;
      border-radius: 12px;
      overflow: hidden;
      text-decoration: none;
      color: inherit;
      transition: all 0.3s;
      display: block;
    }

    .card:hover {
      border-color: #6366f1;
      transform: translateY(-4px);
      box-shadow: 0 10px 40px rgba(99, 102, 241, 0.2);
    }

    .card-preview {
      height: 160px;
      background: #000;
      position: relative;
      overflow: hidden;
    }

    .card-preview canvas {
      width: 100%;
      height: 100%;
      display: block;
    }

    .card-content {
      padding: 20px;
    }

    .card h2 {
      font-size: 16px;
      font-weight: 600;
      margin-bottom: 8px;
    }

    .card p {
      font-size: 12px;
      color: #8888a0;
      line-height: 1.6;
    }

    .card .tag {
      display: inline-block;
      font-size: 10px;
      padding: 4px 8px;
      background: #1a1a24;
      border-radius: 4px;
      margin-top: 12px;
      color: #6366f1;
    }

    .links {
      display: flex;
      gap: 24px;
      font-size: 12px;
    }

    .links a {
      color: #8888a0;
      text-decoration: none;
      transition: color 0.2s;
    }

    .links a:hover {
      color: #6366f1;
    }

    footer {
      margin-top: 48px;
      font-size: 11px;
      color: #555;
    }

    footer a {
      color: #6366f1;
      text-decoration: none;
    }
  </style>
</head>
<body>
  <h1>sheep-viz</h1>
  <p class="tagline">Audio-reactive visuals for musicians who miss the old days.</p>

  <div class="visualizers">
    <a href="visualizers/vertical-pulse-pro.html" class="card">
      <div class="card-preview">
        <canvas id="preview-vertical"></canvas>
      </div>
      <div class="card-content">
        <h2>Vertical Pulse Pro</h2>
        <p>Light columns that breathe with frequency, distorted by organic blobs. Modern UI with MIDI support.</p>
        <span class="tag">MIDI + Fullscreen</span>
      </div>
    </a>

    <a href="visualizers/fluid-flow.html" class="card">
      <div class="card-preview">
        <canvas id="preview-fluid"></canvas>
      </div>
      <div class="card-content">
        <h2>Fluid Flow</h2>
        <p>Particles following velocity fields, pushed by bass, swirling with mids. Inspired by gpu-io.</p>
        <span class="tag">New</span>
      </div>
    </a>

    <a href="visualizers/radial-burst.html" class="card">
      <div class="card-preview">
        <canvas id="preview-radial"></canvas>
      </div>
      <div class="card-content">
        <h2>Radial Burst</h2>
        <p>Particles explode from center on every beat. Trails decay into nothing. Waveform ring pulses.</p>
        <span class="tag">Beat-reactive</span>
      </div>
    </a>

    <a href="visualizers/vector-grid.html" class="card">
      <div class="card-preview">
        <canvas id="preview-vector"></canvas>
      </div>
      <div class="card-content">
        <h2>Vector Grid</h2>
        <p>Johnny Quest-style wireframe terrain. 3D perspective grid with audio-reactive waves. Green phosphor aesthetic.</p>
        <span class="tag">Retro 3D</span>
      </div>
    </a>

    <a href="visualizers/matrix-rain.html" class="card">
      <div class="card-preview">
        <canvas id="preview-matrix"></canvas>
      </div>
      <div class="card-content">
        <h2>Matrix Rain</h2>
        <p>Digital rain with multicolor modes. Japanese katakana characters cascading with audio-reactive glitches.</p>
        <span class="tag">Cyberpunk</span>
      </div>
    </a>

    <a href="visualizers/starfield.html" class="card">
      <div class="card-preview">
        <canvas id="preview-starfield"></canvas>
      </div>
      <div class="card-content">
        <h2>Starfield</h2>
        <p>Classic Windows-style star tunnel. Bass boosts warp speed. Multiple color modes from monochrome to rainbow.</p>
        <span class="tag">Classic</span>
      </div>
    </a>

    <a href="visualizers/warp-speed.html" class="card">
      <div class="card-preview">
        <canvas id="preview-warp"></canvas>
      </div>
      <div class="card-content">
        <h2>Warp Speed</h2>
        <p>Star Wars hyperspace jump. Controllable direction with WASD/mouse. Core glow and color temperature.</p>
        <span class="tag">Cinematic</span>
      </div>
    </a>

    <a href="visualizers/vertical-pulse.html" class="card">
      <div class="card-preview">
        <canvas id="preview-overlay"></canvas>
      </div>
      <div class="card-content">
        <h2>Vertical Pulse (Full)</h2>
        <p>Extended version with overlay system, color extraction, and resolution presets for video export.</p>
        <span class="tag">Overlays + Export</span>
      </div>
    </a>

    <a href="visualizers/llama-bars.html" class="card">
      <div class="card-preview">
        <canvas id="preview-llama"></canvas>
      </div>
      <div class="card-content">
        <h2>Llama Bars</h2>
        <p>Classic spectrum analyzer with gravity peaks. Green-yellow-red gradient. 8 style variants from blocks to LED matrix.</p>
        <span class="tag">Winamp Tribute</span>
      </div>
    </a>

    <a href="visualizers/spilled-milk.html" class="card">
      <div class="card-preview">
        <canvas id="preview-milk"></canvas>
      </div>
      <div class="card-content">
        <h2>Spilled Milk</h2>
        <p>Milkdrop tribute with morphing flow fields, kaleidoscope, zoom tunnels, plasma waves. 8 psychedelic presets.</p>
        <span class="tag">Milkdrop Tribute</span>
      </div>
    </a>

    <a href="visualizers/geist.html" class="card">
      <div class="card-preview">
        <canvas id="preview-geist"></canvas>
      </div>
      <div class="card-content">
        <h2>Geist</h2>
        <p>Tunnel effects with chrome sheen, morphing wormholes, neon tubes, liquid metal blobs. 8 hypnotic presets.</p>
        <span class="tag">Geiss Tribute</span>
      </div>
    </a>

    <a href="visualizers/gogh-mode.html" class="card">
      <div class="card-preview">
        <canvas id="preview-gogh"></canvas>
      </div>
      <div class="card-content">
        <h2>Gogh Mode</h2>
        <p>Swirling brushstrokes inspired by Van Gogh. Starry Night spirals, Sunflower blooms, impasto texture.</p>
        <span class="tag">Van Gogh Tribute</span>
      </div>
    </a>

    <a href="visualizers/gilt-trip.html" class="card">
      <div class="card-preview">
        <canvas id="preview-gilt"></canvas>
      </div>
      <div class="card-content">
        <h2>Gilt Trip</h2>
        <p>Art Nouveau gold patterns inspired by Klimt. Spirals, mosaics, Byzantine halos, shimmering gold leaf.</p>
        <span class="tag">Klimt Tribute</span>
      </div>
    </a>

    <a href="visualizers/cubic-zirconia.html" class="card">
      <div class="card-preview">
        <canvas id="preview-cubic"></canvas>
      </div>
      <div class="card-content">
        <h2>Cubic Zirconia</h2>
        <p>Cubist fragmentation inspired by Picasso. Shattered geometry, multiple perspectives, bold outlines.</p>
        <span class="tag">Picasso Tribute</span>
      </div>
    </a>

    <a href="visualizers/oscilloscope.html" class="card">
      <div class="card-preview">
        <canvas id="preview-oscilloscope"></canvas>
      </div>
      <div class="card-content">
        <h2>Oscilloscope</h2>
        <p>Classic waveform display with Lissajous curves, phosphor glow, and multi-trace modes.</p>
        <span class="tag">Classic</span>
      </div>
    </a>

    <a href="visualizers/pollock-splatter.html" class="card">
      <div class="card-preview">
        <canvas id="preview-pollock"></canvas>
      </div>
      <div class="card-content">
        <h2>Pollock Splatter</h2>
        <p>Action painting with drips, flings, and splatters. Chaotic energy inspired by Jackson Pollock.</p>
        <span class="tag">Art Tribute</span>
      </div>
    </a>
  </div>

  <div class="links">
    <a href="docs/">Documentation</a>
    <a href="https://github.com/electricsheepco/sheep-viz">GitHub</a>
  </div>

  <footer>
    Made by <a href="https://electric-sheep-supply-co.in">Electric Sheep Supply Co.</a>
  </footer>

  <script>
    // Mini visualizer previews
    class MiniVisualizer {
      constructor(canvasId, type) {
        this.canvas = document.getElementById(canvasId);
        this.ctx = this.canvas.getContext('2d');
        this.type = type;
        this.time = Math.random() * 1000;
        this.particles = [];
        this.resize();
        window.addEventListener('resize', () => this.resize());
      }

      resize() {
        const rect = this.canvas.parentElement.getBoundingClientRect();
        this.canvas.width = rect.width * 2;
        this.canvas.height = rect.height * 2;
        this.width = this.canvas.width;
        this.height = this.canvas.height;
      }

      draw() {
        this.time += 0.02;
        const ctx = this.ctx;

        // Fade background
        ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
        ctx.fillRect(0, 0, this.width, this.height);

        switch (this.type) {
          case 'vertical':
            this.drawVertical();
            break;
          case 'fluid':
            this.drawFluid();
            break;
          case 'radial':
            this.drawRadial();
            break;
          case 'vector':
            this.drawVector();
            break;
          case 'matrix':
            this.drawMatrix();
            break;
          case 'starfield':
            this.drawStarfield();
            break;
          case 'warp':
            this.drawWarp();
            break;
          case 'overlay':
            this.drawOverlay();
            break;
          case 'llama':
            this.drawLlama();
            break;
          case 'milk':
            this.drawMilk();
            break;
          case 'geist':
            this.drawGeist();
            break;
          case 'gogh':
            this.drawGogh();
            break;
          case 'gilt':
            this.drawGilt();
            break;
          case 'cubic':
            this.drawCubic();
            break;
          case 'oscilloscope':
            this.drawOscilloscope();
            break;
          case 'pollock':
            this.drawPollock();
            break;
        }

        requestAnimationFrame(() => this.draw());
      }

      drawVertical() {
        const ctx = this.ctx;
        const cols = 30;
        const colW = this.width / cols;

        for (let i = 0; i < cols; i++) {
          const x = i * colW;
          const noise = Math.sin(this.time + i * 0.3) * 0.5 + 0.5;
          const h = this.height * (0.3 + noise * 0.5);

          const gradient = ctx.createLinearGradient(x, this.height - h, x, this.height);
          gradient.addColorStop(0, `hsla(${330 + i * 2}, 100%, 60%, 0)`);
          gradient.addColorStop(0.5, `hsla(${330 + i * 2}, 100%, 60%, ${noise * 0.8})`);
          gradient.addColorStop(1, `hsla(${330 + i * 2}, 100%, 60%, ${noise})`);

          ctx.fillStyle = gradient;
          ctx.fillRect(x, this.height - h, colW - 2, h);
        }
      }

      drawFluid() {
        const ctx = this.ctx;

        // Add particles occasionally
        if (Math.random() < 0.3) {
          this.particles.push({
            x: Math.random() * this.width,
            y: Math.random() * this.height,
            vx: 0,
            vy: 0,
            life: 1,
            hue: Math.random() * 60 + 220
          });
        }

        // Update and draw particles
        for (let i = this.particles.length - 1; i >= 0; i--) {
          const p = this.particles[i];

          // Flow field
          const angle = Math.sin(p.x * 0.01 + this.time) * Math.cos(p.y * 0.01 + this.time) * Math.PI * 2;
          p.vx += Math.cos(angle) * 0.5;
          p.vy += Math.sin(angle) * 0.5;
          p.vx *= 0.95;
          p.vy *= 0.95;

          p.x += p.vx;
          p.y += p.vy;
          p.life -= 0.01;

          if (p.life > 0) {
            ctx.beginPath();
            ctx.arc(p.x, p.y, 3, 0, Math.PI * 2);
            ctx.fillStyle = `hsla(${p.hue}, 80%, 60%, ${p.life})`;
            ctx.fill();
          } else {
            this.particles.splice(i, 1);
          }
        }

        // Limit particles
        if (this.particles.length > 200) {
          this.particles = this.particles.slice(-200);
        }
      }

      drawRadial() {
        const ctx = this.ctx;
        const cx = this.width / 2;
        const cy = this.height / 2;

        // Burst on "beat"
        if (Math.sin(this.time * 2) > 0.9 && Math.random() < 0.3) {
          for (let i = 0; i < 20; i++) {
            const angle = (Math.PI * 2 / 20) * i + Math.random() * 0.2;
            this.particles.push({
              x: cx,
              y: cy,
              vx: Math.cos(angle) * (5 + Math.random() * 5),
              vy: Math.sin(angle) * (5 + Math.random() * 5),
              life: 1,
              hue: 340 + Math.random() * 40
            });
          }
        }

        // Update and draw particles
        for (let i = this.particles.length - 1; i >= 0; i--) {
          const p = this.particles[i];
          p.x += p.vx;
          p.y += p.vy;
          p.vx *= 0.98;
          p.vy *= 0.98;
          p.life -= 0.02;

          if (p.life > 0) {
            ctx.beginPath();
            ctx.arc(p.x, p.y, 4 * p.life, 0, Math.PI * 2);
            ctx.fillStyle = `hsla(${p.hue}, 100%, 60%, ${p.life})`;
            ctx.fill();
          } else {
            this.particles.splice(i, 1);
          }
        }

        // Ring
        const ringR = 60 + Math.sin(this.time * 3) * 10;
        ctx.beginPath();
        ctx.arc(cx, cy, ringR, 0, Math.PI * 2);
        ctx.strokeStyle = `hsla(280, 80%, 60%, 0.5)`;
        ctx.lineWidth = 2;
        ctx.stroke();

        // Limit particles
        if (this.particles.length > 150) {
          this.particles = this.particles.slice(-150);
        }
      }

      drawOverlay() {
        const ctx = this.ctx;
        const cols = 25;
        const colW = this.width / cols;

        // Vertical bars
        for (let i = 0; i < cols; i++) {
          const x = i * colW;
          const noise = Math.sin(this.time * 1.5 + i * 0.4) * 0.5 + 0.5;
          const h = this.height * (0.2 + noise * 0.6);

          const hue = 200 + i * 3;
          ctx.fillStyle = `hsla(${hue}, 80%, 50%, ${noise * 0.7})`;
          ctx.fillRect(x, this.height - h, colW - 2, h);
        }

        // Overlay simulation (centered shape)
        const pulse = Math.sin(this.time * 2) * 0.2 + 0.8;
        const size = 50 * pulse;
        const cx = this.width / 2;
        const cy = this.height / 2;

        ctx.beginPath();
        ctx.arc(cx, cy, size, 0, Math.PI * 2);
        ctx.fillStyle = `rgba(255, 255, 255, ${0.3 * pulse})`;
        ctx.fill();
      }

      drawVector() {
        const ctx = this.ctx;
        ctx.strokeStyle = '#00ff66';
        ctx.lineWidth = 1;

        const gridSize = 8;
        const cellW = this.width / gridSize;
        const cellH = this.height / 3;
        const offsetY = this.height * 0.3;

        // Draw grid lines
        for (let i = 0; i <= gridSize; i++) {
          ctx.beginPath();
          ctx.moveTo(i * cellW, offsetY);
          for (let j = 0; j <= gridSize; j++) {
            const wave = Math.sin(i * 0.5 + this.time) * Math.sin(j * 0.5 + this.time) * 30;
            ctx.lineTo(i * cellW, offsetY + j * (cellH / gridSize) + wave);
          }
          ctx.stroke();
        }

        for (let j = 0; j <= gridSize; j++) {
          ctx.beginPath();
          for (let i = 0; i <= gridSize; i++) {
            const wave = Math.sin(i * 0.5 + this.time) * Math.sin(j * 0.5 + this.time) * 30;
            const x = i * cellW;
            const y = offsetY + j * (cellH / gridSize) + wave;
            if (i === 0) ctx.moveTo(x, y);
            else ctx.lineTo(x, y);
          }
          ctx.stroke();
        }
      }

      drawMatrix() {
        const ctx = this.ctx;
        const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789@#$%^&*';
        const fontSize = 14;
        const cols = Math.floor(this.width / fontSize);

        if (!this.matrixStreams) {
          this.matrixStreams = [];
          for (let i = 0; i < cols; i++) {
            this.matrixStreams.push({
              y: Math.random() * this.height,
              speed: 2 + Math.random() * 4
            });
          }
        }

        ctx.font = `${fontSize}px monospace`;

        for (let i = 0; i < cols; i++) {
          const s = this.matrixStreams[i];
          const char = chars[Math.floor(Math.random() * chars.length)];
          const hue = (this.time * 50 + i * 10) % 360;

          // Head character (bright)
          ctx.fillStyle = `hsla(${hue}, 100%, 70%, 1)`;
          ctx.fillText(char, i * fontSize, s.y);

          // Trail
          ctx.fillStyle = `hsla(${hue}, 100%, 50%, 0.3)`;
          for (let j = 1; j < 5; j++) {
            const tc = chars[Math.floor(Math.random() * chars.length)];
            ctx.fillText(tc, i * fontSize, s.y - j * fontSize);
          }

          s.y += s.speed;
          if (s.y > this.height + 100) {
            s.y = -50;
            s.speed = 2 + Math.random() * 4;
          }
        }
      }

      drawStarfield() {
        const ctx = this.ctx;
        const cx = this.width / 2;
        const cy = this.height / 2;

        if (!this.stars) {
          this.stars = [];
          for (let i = 0; i < 100; i++) {
            this.stars.push({
              x: (Math.random() - 0.5) * this.width,
              y: (Math.random() - 0.5) * this.height,
              z: Math.random() * this.width
            });
          }
        }

        const speed = 10 + Math.sin(this.time) * 5;

        for (let s of this.stars) {
          s.z -= speed;
          if (s.z < 1) {
            s.x = (Math.random() - 0.5) * this.width;
            s.y = (Math.random() - 0.5) * this.height;
            s.z = this.width;
          }

          const sx = cx + (s.x / s.z) * this.width * 0.5;
          const sy = cy + (s.y / s.z) * this.height * 0.5;
          const r = Math.max(0, (1 - s.z / this.width) * 3);
          const b = Math.max(50, 255 - (s.z / this.width) * 200);

          ctx.beginPath();
          ctx.arc(sx, sy, r, 0, Math.PI * 2);
          ctx.fillStyle = `rgba(${b}, ${b}, ${b * 0.95}, 1)`;
          ctx.fill();
        }
      }

      drawLlama() {
        const ctx = this.ctx;
        const bars = 24;
        const barW = this.width / bars;
        const maxH = this.height * 0.75;
        const baseY = this.height * 0.85;

        // Initialize bar data
        if (!this.llamaBars) {
          this.llamaBars = [];
          this.llamaPeaks = [];
          this.llamaPeakVel = [];
          for (let i = 0; i < bars; i++) {
            this.llamaBars.push(0);
            this.llamaPeaks.push(0);
            this.llamaPeakVel.push(0);
          }
        }

        // Simulate audio
        for (let i = 0; i < bars; i++) {
          const target = Math.pow(Math.sin(this.time * 2 + i * 0.3) * 0.5 + 0.5, 1.5) * maxH;
          this.llamaBars[i] += (target - this.llamaBars[i]) * 0.3;

          // Update peaks with gravity
          if (this.llamaBars[i] > this.llamaPeaks[i]) {
            this.llamaPeaks[i] = this.llamaBars[i];
            this.llamaPeakVel[i] = 0;
          } else {
            this.llamaPeakVel[i] += 0.5;
            this.llamaPeaks[i] -= this.llamaPeakVel[i];
            if (this.llamaPeaks[i] < 0) this.llamaPeaks[i] = 0;
          }
        }

        // Draw bars as blocks
        for (let i = 0; i < bars; i++) {
          const x = i * barW;
          const h = this.llamaBars[i];
          const blockH = 6;
          const gap = 2;
          const numBlocks = Math.floor(h / (blockH + gap));

          for (let j = 0; j < numBlocks; j++) {
            const blockY = baseY - (j + 1) * (blockH + gap);
            const pct = (j * (blockH + gap)) / maxH;
            // Green -> Yellow -> Red
            let r, g, b;
            if (pct < 0.5) {
              r = Math.floor(255 * pct * 2);
              g = 255;
            } else {
              r = 255;
              g = Math.floor(255 * (1 - (pct - 0.5) * 2));
            }
            ctx.fillStyle = `rgb(${r}, ${g}, 0)`;
            ctx.fillRect(x + 1, blockY, barW - 3, blockH);
          }

          // Draw peak
          if (this.llamaPeaks[i] > 2) {
            const peakY = baseY - this.llamaPeaks[i];
            const pct = this.llamaPeaks[i] / maxH;
            let r, g;
            if (pct < 0.5) {
              r = Math.floor(255 * pct * 2);
              g = 255;
            } else {
              r = 255;
              g = Math.floor(255 * (1 - (pct - 0.5) * 2));
            }
            ctx.fillStyle = `rgb(${r}, ${g}, 0)`;
            ctx.fillRect(x + 1, peakY - 3, barW - 3, 3);
          }
        }
      }

      drawMilk() {
        const ctx = this.ctx;
        const cx = this.width / 2;
        const cy = this.height / 2;

        // Psychedelic morphing flow field
        const hue = (this.time * 30) % 360;
        const segments = 6;
        const angleStep = (Math.PI * 2) / segments;

        ctx.save();
        ctx.translate(cx, cy);

        // Kaleidoscope segments
        for (let seg = 0; seg < segments; seg++) {
          ctx.save();
          ctx.rotate(seg * angleStep + this.time * 0.2);

          if (seg % 2 === 1) {
            ctx.scale(1, -1);
          }

          // Draw flowing shapes in segment
          for (let i = 0; i < 8; i++) {
            const dist = 30 + i * 15 + Math.sin(this.time + i) * 20;
            const size = 8 + Math.sin(this.time * 2 + i * 0.5) * 5;
            const shapeAngle = this.time * 0.5 + i * 0.3;

            const x = Math.cos(shapeAngle * 0.5) * dist;
            const y = Math.sin(shapeAngle) * dist * 0.3;

            const shapeHue = (hue + i * 30 + seg * 40) % 360;
            ctx.fillStyle = `hsla(${shapeHue}, 90%, 55%, 0.6)`;
            ctx.beginPath();
            ctx.arc(x, y, size, 0, Math.PI * 2);
            ctx.fill();
          }

          ctx.restore();
        }

        ctx.restore();

        // Center glow
        const gradient = ctx.createRadialGradient(cx, cy, 0, cx, cy, 60);
        gradient.addColorStop(0, `hsla(${hue}, 100%, 70%, 0.4)`);
        gradient.addColorStop(0.5, `hsla(${(hue + 60) % 360}, 80%, 50%, 0.2)`);
        gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, this.width, this.height);
      }

      drawGeist() {
        const ctx = this.ctx;
        const cx = this.width / 2;
        const cy = this.height / 2;
        const maxRadius = Math.max(this.width, this.height) * 0.6;

        // Tunnel rings
        const numRings = 15;
        for (let i = numRings; i >= 0; i--) {
          const progress = (i + this.time * 2) % numRings / numRings;
          const radius = progress * maxRadius;

          if (radius < 10) continue;

          const hue = (this.time * 40 + progress * 180) % 360;
          const lightness = 40 + progress * 20;

          ctx.strokeStyle = `hsla(${hue}, 70%, ${lightness}%, ${0.3 + (1 - progress) * 0.5})`;
          ctx.lineWidth = 1 + (1 - progress) * 3;

          ctx.beginPath();

          // Hexagon shape
          const sides = 6;
          const rotation = this.time * 0.5 + progress * 0.5;
          for (let j = 0; j <= sides; j++) {
            const angle = (j / sides) * Math.PI * 2 + rotation;
            const wobble = Math.sin(angle * 2 + this.time * 3) * 10 * progress;
            const x = cx + Math.cos(angle) * (radius + wobble);
            const y = cy + Math.sin(angle) * (radius + wobble);

            if (j === 0) ctx.moveTo(x, y);
            else ctx.lineTo(x, y);
          }

          ctx.closePath();
          ctx.stroke();
        }

        // Chrome center glow
        const coreGradient = ctx.createRadialGradient(cx, cy, 0, cx, cy, 40);
        coreGradient.addColorStop(0, 'rgba(0, 255, 255, 0.4)');
        coreGradient.addColorStop(0.5, 'rgba(0, 200, 255, 0.2)');
        coreGradient.addColorStop(1, 'rgba(0, 150, 255, 0)');
        ctx.fillStyle = coreGradient;
        ctx.fillRect(0, 0, this.width, this.height);
      }

      drawGogh() {
        const ctx = this.ctx;
        const w = this.width;
        const h = this.height;

        // Van Gogh palette - deep blues, bright yellows
        const colors = [
          [25, 25, 112],    // midnight blue
          [65, 105, 225],   // royal blue
          [255, 215, 0],    // gold
          [255, 255, 200],  // cream
        ];

        // Initialize strokes if needed
        if (!this.goghStrokes) {
          this.goghStrokes = [];
          for (let i = 0; i < 50; i++) {
            this.goghStrokes.push({
              x: Math.random() * w,
              y: Math.random() * h,
              seed: Math.random() * 1000,
              color: colors[Math.floor(Math.random() * colors.length)],
              length: 15 + Math.random() * 25
            });
          }
        }

        // Draw swirling brushstrokes
        for (const stroke of this.goghStrokes) {
          ctx.beginPath();
          ctx.moveTo(stroke.x, stroke.y);

          let px = stroke.x;
          let py = stroke.y;

          for (let j = 0; j < stroke.length; j++) {
            // Swirling flow field
            const scale = 0.005;
            const angle = Math.sin(px * scale * 2 + this.time) *
                         Math.cos(py * scale * 2 + this.time * 0.7) * Math.PI * 2;

            // Add big swirl around center
            const dx = px - w / 2;
            const dy = py - h / 3;
            const swirl = Math.atan2(dy, dx) + Math.sin(Math.sqrt(dx*dx + dy*dy) * 0.01 + this.time) * 0.5;
            const finalAngle = angle * 0.4 + swirl * 0.6;

            px += Math.cos(finalAngle) * 3;
            py += Math.sin(finalAngle) * 3;

            ctx.lineTo(px, py);
          }

          const c = stroke.color;
          ctx.strokeStyle = `rgba(${c[0]}, ${c[1]}, ${c[2]}, 0.6)`;
          ctx.lineWidth = 3 + Math.sin(this.time + stroke.seed) * 1.5;
          ctx.lineCap = 'round';
          ctx.stroke();

          // Move stroke origin slowly
          stroke.x += (Math.random() - 0.5) * 2;
          stroke.y += (Math.random() - 0.5) * 2;

          // Wrap around
          if (stroke.x < 0) stroke.x = w;
          if (stroke.x > w) stroke.x = 0;
          if (stroke.y < 0) stroke.y = h;
          if (stroke.y > h) stroke.y = 0;
        }
      }

      drawGilt() {
        const ctx = this.ctx;
        const w = this.width;
        const h = this.height;
        const cx = w / 2;
        const cy = h / 2;

        // Gold colors
        const golds = [
          [212, 175, 55],
          [255, 215, 0],
          [218, 165, 32],
          [255, 223, 128],
        ];

        // Draw spiraling golden patterns
        const numSpirals = 8;
        for (let s = 0; s < numSpirals; s++) {
          const baseAngle = (s / numSpirals) * Math.PI * 2 + this.time * 0.3;
          const radius = 40 + s * 15;

          ctx.beginPath();
          for (let i = 0; i <= 30; i++) {
            const progress = i / 30;
            const angle = baseAngle + progress * Math.PI * 3;
            const r = radius * progress;
            const x = cx + Math.cos(angle) * r;
            const y = cy + Math.sin(angle) * r;

            if (i === 0) ctx.moveTo(x, y);
            else ctx.lineTo(x, y);
          }

          const gold = golds[s % golds.length];
          const shimmer = Math.sin(this.time * 4 + s) * 0.3 + 0.7;
          ctx.strokeStyle = `rgba(${gold[0]}, ${gold[1]}, ${gold[2]}, ${shimmer * 0.7})`;
          ctx.lineWidth = 2;
          ctx.stroke();
        }

        // Decorative circles
        for (let ring = 0; ring < 4; ring++) {
          const ringRadius = 60 + ring * 30;
          const numDots = 8 + ring * 4;

          for (let i = 0; i < numDots; i++) {
            const angle = (i / numDots) * Math.PI * 2 + this.time * 0.2 * (ring % 2 === 0 ? 1 : -1);
            const x = cx + Math.cos(angle) * ringRadius;
            const y = cy + Math.sin(angle) * ringRadius;

            const gold = golds[(i + ring) % golds.length];
            const shimmer = Math.sin(this.time * 3 + i + ring) * 0.3 + 0.7;

            ctx.beginPath();
            ctx.arc(x, y, 4 + ring, 0, Math.PI * 2);
            ctx.fillStyle = `rgba(${gold[0]}, ${gold[1]}, ${gold[2]}, ${shimmer * 0.8})`;
            ctx.fill();
          }
        }

        // Center ornament
        const centerGradient = ctx.createRadialGradient(cx, cy, 0, cx, cy, 30);
        centerGradient.addColorStop(0, 'rgba(255, 255, 255, 0.6)');
        centerGradient.addColorStop(0.5, 'rgba(212, 175, 55, 0.5)');
        centerGradient.addColorStop(1, 'rgba(184, 134, 11, 0.3)');
        ctx.beginPath();
        ctx.arc(cx, cy, 30, 0, Math.PI * 2);
        ctx.fillStyle = centerGradient;
        ctx.fill();
      }

      drawCubic() {
        const ctx = this.ctx;
        const w = this.width;
        const h = this.height;

        // Cubist color palette - muted earth tones
        const colors = [
          [139, 119, 101],
          [169, 154, 134],
          [101, 91, 79],
          [230, 57, 70],
          [69, 123, 157],
        ];

        // Initialize fragments if needed
        if (!this.cubicFragments) {
          this.cubicFragments = [];
          for (let i = 0; i < 25; i++) {
            this.cubicFragments.push({
              x: Math.random() * w,
              y: Math.random() * h,
              size: 20 + Math.random() * 40,
              rotation: Math.random() * Math.PI * 2,
              rotSpeed: (Math.random() - 0.5) * 0.02,
              vertices: 3 + Math.floor(Math.random() * 4),
              color: colors[Math.floor(Math.random() * colors.length)]
            });
          }
        }

        // Draw fragmented shapes
        for (const frag of this.cubicFragments) {
          ctx.save();
          ctx.translate(frag.x, frag.y);
          ctx.rotate(frag.rotation);

          ctx.beginPath();
          for (let i = 0; i <= frag.vertices; i++) {
            const angle = (i / frag.vertices) * Math.PI * 2;
            const radiusVar = 0.6 + Math.sin(angle * 2 + this.time) * 0.4;
            const r = frag.size * radiusVar;
            const px = Math.cos(angle) * r;
            const py = Math.sin(angle) * r;

            if (i === 0) ctx.moveTo(px, py);
            else ctx.lineTo(px, py);
          }
          ctx.closePath();

          const c = frag.color;
          ctx.fillStyle = `rgba(${c[0]}, ${c[1]}, ${c[2]}, 0.5)`;
          ctx.fill();

          ctx.strokeStyle = 'rgba(0, 0, 0, 0.4)';
          ctx.lineWidth = 1.5;
          ctx.stroke();

          ctx.restore();

          // Update rotation
          frag.rotation += frag.rotSpeed;
        }
      }

      drawOscilloscope() {
        const ctx = this.ctx;
        const w = this.width;
        const h = this.height;
        const cx = w / 2;
        const cy = h / 2;

        // Draw grid
        ctx.strokeStyle = 'rgba(0, 255, 136, 0.15)';
        ctx.lineWidth = 1;
        for (let i = 0; i < 8; i++) {
          const x = (w / 8) * i;
          const y = (h / 8) * i;
          ctx.beginPath();
          ctx.moveTo(x, 0);
          ctx.lineTo(x, h);
          ctx.stroke();
          ctx.beginPath();
          ctx.moveTo(0, y);
          ctx.lineTo(w, y);
          ctx.stroke();
        }

        // Draw waveform with glow
        ctx.strokeStyle = '#00ff88';
        ctx.lineWidth = 2;
        ctx.shadowColor = '#00ff88';
        ctx.shadowBlur = 15;

        ctx.beginPath();
        for (let i = 0; i < w; i++) {
          const x = i;
          const freq1 = Math.sin((i / w) * Math.PI * 4 + this.time * 2);
          const freq2 = Math.sin((i / w) * Math.PI * 8 + this.time * 3) * 0.3;
          const y = cy + (freq1 + freq2) * h * 0.2;
          if (i === 0) ctx.moveTo(x, y);
          else ctx.lineTo(x, y);
        }
        ctx.stroke();

        // Draw Lissajous curve
        ctx.strokeStyle = '#00ffff';
        ctx.beginPath();
        const scale = Math.min(w, h) * 0.25;
        for (let i = 0; i < 200; i++) {
          const t = (i / 200) * Math.PI * 2;
          const x = cx + Math.sin(t * 3 + this.time) * scale;
          const y = cy + Math.sin(t * 4 + this.time * 1.1) * scale * 0.8;
          if (i === 0) ctx.moveTo(x, y);
          else ctx.lineTo(x, y);
        }
        ctx.stroke();
        ctx.shadowBlur = 0;
      }

      drawPollock() {
        const ctx = this.ctx;
        const w = this.width;
        const h = this.height;

        // Color palette
        const colors = ['#1a1a1a', '#f5f5dc', '#c4a747', '#8b4513', '#2f4f4f', '#ff6b35'];

        // Initialize splats
        if (!this.pollockSplats) {
          this.pollockSplats = [];
          this.pollockDrips = [];
        }

        // Add new splats periodically
        if (Math.random() < 0.15) {
          this.pollockSplats.push({
            x: Math.random() * w,
            y: Math.random() * h,
            size: 10 + Math.random() * 30,
            color: colors[Math.floor(Math.random() * colors.length)],
            age: 0
          });

          // Maybe add a drip
          if (Math.random() < 0.3) {
            const x = Math.random() * w;
            this.pollockDrips.push({
              x: x,
              y: Math.random() * h * 0.3,
              length: 50 + Math.random() * 100,
              progress: 0,
              color: colors[Math.floor(Math.random() * colors.length)],
              thickness: 2 + Math.random() * 4
            });
          }
        }

        // Draw splats
        for (let i = this.pollockSplats.length - 1; i >= 0; i--) {
          const s = this.pollockSplats[i];
          const alpha = Math.max(0, 1 - s.age / 60);
          ctx.fillStyle = s.color;
          ctx.globalAlpha = alpha;

          ctx.beginPath();
          const points = 6 + Math.floor(Math.random() * 4);
          for (let j = 0; j <= points; j++) {
            const angle = (j / points) * Math.PI * 2;
            const r = s.size * (0.5 + Math.random() * 0.5);
            const px = s.x + Math.cos(angle) * r;
            const py = s.y + Math.sin(angle) * r;
            if (j === 0) ctx.moveTo(px, py);
            else ctx.lineTo(px, py);
          }
          ctx.closePath();
          ctx.fill();

          s.age++;
          if (s.age > 60) this.pollockSplats.splice(i, 1);
        }

        // Draw drips
        ctx.globalAlpha = 1;
        for (let i = this.pollockDrips.length - 1; i >= 0; i--) {
          const d = this.pollockDrips[i];
          ctx.strokeStyle = d.color;
          ctx.lineWidth = d.thickness;
          ctx.lineCap = 'round';

          const endY = d.y + d.length * d.progress;
          ctx.beginPath();
          ctx.moveTo(d.x, d.y);
          ctx.lineTo(d.x + Math.sin(d.progress * 5) * 10, endY);
          ctx.stroke();

          d.progress += 0.02;
          if (d.progress > 1.5) this.pollockDrips.splice(i, 1);
        }

        ctx.globalAlpha = 1;
      }

      drawWarp() {
        const ctx = this.ctx;
        const cx = this.width / 2;
        const cy = this.height / 2;

        if (!this.warpStars) {
          this.warpStars = [];
          for (let i = 0; i < 150; i++) {
            const angle = Math.random() * Math.PI * 2;
            const radius = Math.random() * this.width * 0.4;
            this.warpStars.push({
              x: Math.cos(angle) * radius,
              y: Math.sin(angle) * radius,
              z: Math.random() * this.width,
              pz: Math.random() * this.width
            });
          }
        }

        const speed = 20 + Math.sin(this.time * 2) * 10;

        // Core glow
        const gradient = ctx.createRadialGradient(cx, cy, 0, cx, cy, 100);
        gradient.addColorStop(0, 'rgba(100, 150, 255, 0.3)');
        gradient.addColorStop(1, 'rgba(100, 150, 255, 0)');
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, this.width, this.height);

        for (let s of this.warpStars) {
          s.z -= speed;
          if (s.z < 1) {
            const angle = Math.random() * Math.PI * 2;
            const radius = Math.random() * this.width * 0.4;
            s.x = Math.cos(angle) * radius;
            s.y = Math.sin(angle) * radius;
            s.z = this.width;
            s.pz = s.z;
          }

          const sx = cx + (s.x / s.z) * this.width;
          const sy = cy + (s.y / s.z) * this.height;
          const px = cx + (s.x / s.pz) * this.width;
          const py = cy + (s.y / s.pz) * this.height;

          const b = Math.max(80, 255 - (s.z / this.width) * 175);

          ctx.beginPath();
          ctx.moveTo(px, py);
          ctx.lineTo(sx, sy);
          ctx.strokeStyle = `rgba(${b * 0.8}, ${b * 0.9}, 255, 0.8)`;
          ctx.lineWidth = Math.max(0.5, (1 - s.z / this.width) * 3);
          ctx.stroke();

          s.pz = s.z + (this.width - s.z) * 0.2;
        }
      }
    }

    // Initialize all previews
    const previews = [
      new MiniVisualizer('preview-vertical', 'vertical'),
      new MiniVisualizer('preview-fluid', 'fluid'),
      new MiniVisualizer('preview-radial', 'radial'),
      new MiniVisualizer('preview-vector', 'vector'),
      new MiniVisualizer('preview-matrix', 'matrix'),
      new MiniVisualizer('preview-starfield', 'starfield'),
      new MiniVisualizer('preview-warp', 'warp'),
      new MiniVisualizer('preview-overlay', 'overlay'),
      new MiniVisualizer('preview-llama', 'llama'),
      new MiniVisualizer('preview-milk', 'milk'),
      new MiniVisualizer('preview-geist', 'geist'),
      new MiniVisualizer('preview-gogh', 'gogh'),
      new MiniVisualizer('preview-gilt', 'gilt'),
      new MiniVisualizer('preview-cubic', 'cubic'),
      new MiniVisualizer('preview-oscilloscope', 'oscilloscope'),
      new MiniVisualizer('preview-pollock', 'pollock')
    ];

    previews.forEach(p => p.draw());
  </script>
</body>
</html>
